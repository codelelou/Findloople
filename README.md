# 概要
プログラミング不要でループ系お探しゲームが作れるテンプレートです。  
進行に応じてフラグの抽選を行い、フラグ有りの時はゲーム内に変化が起こり、それを探すゲームになります。  

話題の「8番ライク」も異変探しゲームとして作れます。  
フラグ（異変）有りの時に変化（異変）が起き、異変を見つけたら引き返す、見つからなかったら引き返さないといったゲームもプログラミング不要で作成可能です。  

開発の手順は「レベル作成」「フラグリスト作成」「フラグ設定」の3ステップ。  

まずはシティシム感覚で、お探しゲームの舞台となるレベル（地形や建物）を3Dモデルなどを配置して作成します（無料の3Dモデルでも高品質なものが多数あります、スマホでスキャンしたものを3Dモデル化することも可能です）。  
レベル作成が終わればゲームの大半が完成したようなもので、後はフラグリストを作成し、レベルに配置したオブジェクトにフラグを設定するだけです。  

# デモゲーム
実際に作れるゲームをイメージしやすいようにデモゲームを用意しています。  
* [ネコ探しゲーム](https://codelelou.itch.io/find-cat)（ネコのキャラクター以外は無料アセットのみ使用）
* [8番ライク作成事例](https://codelelou.itch.io/findloople-demo-game-exit-8-like)（無料アセットのみ使用）

またデモゲームではありませんが、このテンプレートのベースとして開発した有料の8番ライクゲーム「[Phantom Ten](https://store.steampowered.com/app/3070690/Phantom_Ten/)」もあります。  
こちらは進むしかできず、異変を見つけたら左に、見つからなかったら右に進むタイプの8番ライクです。  

# 導入（開発環境構築）
このゲームのテンプレートはゲームエンジンのUnreal Engineのプロジェクトファイルのため、Unreal Engineをインストールする必要があります。  

## Unreal Engineのバージョン
Unreal Engine 5.4  

このバージョン以降のもであれば動作する可能性は高いですが、Unreal Engineのアップデートによっては下位互換がなくなりそのままでは正常に動作しなくなることはあります。  
この場合はこのゲームのテンプレートの対応バージョンのUnreal Engineをインストールしてください（1つの端末に異なる複数のバージョンのUnreal Engineのインストールは可能です）。  

なお、このゲームのテンプレートのアップデート時に対応するUnreal Engineのバージョンが変更になることもあります。  

## Unreal Engineのインストール
インストールについてはUnreal Engine全般のテーマのため、詳しくは[Unreal Engineダウンロードページ](https://www.unrealengine.com/ja/download)や解説動画などを参考にしてください。  

「Unreal Engine インストール」や「Unreal Engine 入門」などのキーワードで探してみてください。  
このゲームのテンプレートを編集する前に、入門者向け・初心者向けの動画などでイメージを掴んだり、Unreal Engineそのものに慣れておくのも良いと思います。  

## ゲームのテンプレートをダウンロードする
GitHubページ上の緑色の［Code］ボタンを左クリックし、表示されるメニューの［Download ZIP］ボタンを左クリックします。  
そして案内に従ってそのZIPファイルを端末に保存します。  

ダウンロードが完了したらそのZIPファイルをわかりやすい場所に展開（解凍）します。  
ゲーム開発ではSSDなどの高速ストレージに展開することを推奨します。  

またディレクトリ構造が深いとゲームエンジンの不具合に繋がることがあるため、浅いディレクトリ階層に展開してください（例えば「D:\UnrealProjects\Findloople」など）。  
あわせて親フォルダも含めてフォルダ名は半角英数字のみで構成するようにしてください（Unreal Engineに限らずゲーム開発ではフォルダ名・ファイル名に日本語があると不具合の原因になることがあります）。  

そして展開したUnreal EngineプロジェクトファイルであるFindloople.uproject（ファイル名は変更可能ですが、Unreal Engineの仕様により20文字以内推奨）をダブルクリックすれば、対応するUnreal Engineが起動し編集できるようになると思います。  
もし直接開けない場合は、次で説明するUnreal Engineを起動してからプロジェクトファイルを指定して開く方法を試してください。  

## Unreal Engineを起動する
起動するとプロジェクトブラウザが開くと思うので、左上の［最近使用したプロジェクト］を左クリックし、右下の［ブラウズ］ボタンを左クリックしてください（以前からUnreal Engineを使っている場合は自動的に最近開いていたプロジェクトが自動ロードされてしまっている場合があるので、その場合はそれを閉じてプロジェクトブラウザを開いてください）。  

そして先程ダウンロードして展開したゲームのテンプレートのアンリアルプロジェクトファイル「Findloople.uproject」を開いてください。  
これでこのゲームのテンプレートを編集できるようになると思います。  

# お探しループゲームの作り方
開発の手順は大きく「レベル作成」「フラグリスト作成」「フラグ設定」の3ステップ。  

レベル作成でゲームの大部分が完成し、レベル作成はシティシムで地形や建物を作るようなイメージです。  
はじめは既存のサンプルレベルを装飾する感じで3Dモデルを配置するだけにして、Unreal Engineに慣れることを目標にしても良いと思います。  

レベル作成が終わったらフラグリストを作成し、そのフラグをレベル上のオブジェクトに設定していくだけです。  
ゲームの進行やフラグの抽選、メニュー表示などはプログラミング済みです。  

## お探しループゲームのルール設定
Osgs_BP_FlagMasterブループリント（/Content/Osagashi/Findloople/Osgs_BP_FlagMaster.uasset）を開き、画面中央上部のデフォルトボタンを左クリックし、右側の詳細タブの［設定］にある項目をお好みで変更してください。  

![Osgs_BP_FlagMasterブループリントの設定変数の場所](https://github.com/user-attachments/assets/306f4ea8-0a95-447a-b527-fb4397daf767)

* FlagDataTable…フラグリストデータテーブルファイル。
* LastRound…クリア条件基準となるラウンド数。
* MustNoFlagLastRoundEndCondition…LastRoundにフラグがない時をクリア条件に含めるか（確率100%固定時はこの設定を無視）。
* BaseProbability…基本抽選確率。
* ZeroRoundProbability…0ラウンドの抽選確率。
* LastRoundProbability…最終ラウンドの抽選確率
* DifficultTag…フラグリストでこのタグを持つフラグは終盤に優先的に発生。
* PermissileNoFlags…連続フラグ無し許容回数。
* Mode…失敗時0に戻る／失敗時1つ前まで戻る／確率100％固定。

## 【ステップ1】 レベル作成（地形や建物などのマップ作成）
Osgs_Level_Topレベルファイル（/Content/Osagashi/Level/Osgs_Level_Top.umap）を開き、サンプルレベルを編集（装飾・改造）する感じでレベルを作成します。
デフォルト設定のままならエディタ起動時にこのレベルファイルが開くと思います。  

なおUnreal Engineでのゲーム開発において「レベル」はゲームの舞台となる地形や建物などステージとなる「マップ」を指し、経験値や難易度の意味ではありません。  
またレベル上に配置する3Dモデルや光源、オーディオファイルなどは「アクター」と呼びます（プログラムファイルであるブループリントに「アクター」クラスが名称が混在してややこしいですが注意してください）。  

### まずはサンプルゲームをプレイしよう
動作確認を兼ねて、エディタ上でサンプルゲームをプレイしてみましょう（開発中の動作確認やテストプレイでよく使うことになる基本操作でもあります）。  
そもそもサンプルゲームが動かなければ、これから作るゲームも動かないでしょう。  

エディタ上部中央あたりに表示されるプレイボタン（再生ボタン）か、その横の縦3つ点ボタンから「選択ビューポート」か「新規エディタウィンドウ（PIE）」を左クリックします。  
サンプルゲームはキーボード・マウスだけでなく、Xboxコントローラーが接続されて入ればゲームパッドでのプレイも可能です（PlayStationやSwitchのコントローラーなどはWindowsに標準対応ではないのためそのままでは使えません）。  

![レベルプレイボタンの位置の図解](https://github.com/user-attachments/assets/1d6131dd-5f43-479e-97eb-7970e2535654)

このプレイモードはEscキーで終了します。

ゲーム内のメニュー表示はゲームパッドのオプションボタンかPキーで開きます（本来はEscキーでも開きますが、エディタ側の設定によりプレイモード自体が終了してしまいます）。  
なおプレイモードが「スタンドアローンゲーム」の時はEscキーでは終了しません（この場合はゲーム内メニューの終了ボタンから終了できます）。  

また言語変更もプレイモード「スタンドアローンゲーム」でないと正常に動作しません（これ以外のプレイモードで言語を変更するとエディタの表示言語が切り替わる恐れがあります）。  

#### クリア後のゲーム開始位置
クリア後はゲーム開始位置が見つかっていないフラグの案内の前からはじまるようになります。  

初回起動時と同じ場所からプレイする場合は見つかったフラグの履歴データをリセットする必要があります。  
ゲーム内メニューの［見つかったモノ］ボタンから一覧を開き、右上のリセットボタンからリセットできます。  

なおクリア後のゲーム開始位置は変更可能ですが、フラグ管理に影響があり位置が悪いとバグの原因となるため注意が必要です。  
もしクリア後のゲームプレイに支障が出るような場合は、クリア後のゲーム開始位置の切替自体を諦める判断も必要です（不具合が発生した場合の修正は上級者向けとなります）。  

### レベル作成の注意点（制約）
レベル上にはプレイヤーがどのように移動しているを把握するための見えない当たり判定（トリガー）があります。  
このトリガーによって回答（見つけた・見つからなかった）の受付や、進行方向のステージの事前読込などを行っています。  

レベルの構造によってはこれらのトリガーを避けて通れるようになる恐れがあり、それにより正常に回答を受け付けられなかったり、進行先のステージが読み込まれなかったりといったバグ発生に繋がりかねません。  
このゲームのテンプレートに慣れるまでは、これらのトリガーの移動・拡大縮小は避け、可能な限りサンプルの通路（床・壁）に沿ってオブジェクト配置するようにしてください。  

### レベル本体の編集
Osgs_Level_Topレベルファイルはサンプルゲームの大本となるレベルですが、ループ表示されるステージ本体はOsgs_Level_MainStageレベルファイルになります。  

Osgs_Level_Topレベル上にOsgs_Level_MainStageレベルを読み込み、ゲーム進行に応じて複数のOsgs_Level_MainStageレベルを表示することでループを実現しています。  
そのためOsgs_Level_Topレベル上に直接配置したオブジェクトはループ処理には使われないので注意してください。  

そしてOsgs_Level_Topレベル上のOsgs_Level_MainStageレベルはそのままではロック状態（編集不可）のため、まずはそれを解除（編集可能）する必要があります。  
Osgs_Level_Topレベル上でOsgs_Level_MainStageレベルを選択状態にして、右クリックして表示されるメニューから［レベル > 編集］を左クリックし、編集可能状態にします。  

![レベルインスタンスの編集不可解除の図解](https://github.com/user-attachments/assets/72c3830c-2686-4ae6-a114-156a53d947be)

編集後は保存し、画面下部中央に表示されている［Osgs_Level_MainStage 終了］の［終了］ボタンを左クリックします。  

![レベルインスタンス編集終了ボタンの位置の図解](https://github.com/user-attachments/assets/348b5cd9-9976-4d7b-b9ee-38ac8c7e496e)

#### サンプルのオブジェクトを移動・複製・削除してみよう  
まずは練習として、Osgs_Level_MainStageレベル上のアルファベットのA～Hのどれかを移動・複製・削除してみてください。  
これらのアルファベットはサンプルゲームではただの飾りのため、変に移動・複製・削除しても特に影響がありません（フラグが立った時に表示されるのもを隠すように配置すると影響は出ます）。  

編集したいオブジェクトを選択すると3方向矢印（XYZ軸）が表示されると思います（3方向矢印以外の時はキーボードのWキーで操作の種類を移動に切り替えてください）。  
移動したい方向の矢印をドラッグして移動できます。  
Altキーを押しながら移動させると複製されたものが移動します。  
移動させずにDeleteキーを押せば削除できます。  

![操作モード切替ボタンの位置の図解](https://github.com/user-attachments/assets/5023338d-141d-4369-835c-f27efbc07191)

他のオブジェクトを編集しても良いですが、床や壁を消してしまうとプレイヤーの落下に繋がったりそもそも道を進めなくなる恐れがあります。  
またフラグ設定されているオブジェクト（例えば乱雑に貼られた禁煙ポスターなど）を消そうとすると、参照されているオブジェクトとしてメッセージが表示されると思うので、その時はキャンセルし誤って削除しないように注意してください。  

![参照中のオブジェクトを消そうとする時に表示されるメッセージ](https://github.com/user-attachments/assets/8e83fac7-99a7-4727-9869-2df2a8bd9261)

移動・複製・削除を行ったら、エディタ上でプレイし、ループしても毎回同じようにその編集が反映されているかを確認します。  

#### オブジェクトを追加してみよう
エディタ上部左側にある立方体に緑のプラス記号付いたボタンを左クリックして表示されるメニュー内の［形状］から［キューブ］をレベル上に配置してみましょう。  

![キューブ追加ボタンの位置の図解](https://github.com/user-attachments/assets/efa96e9d-3702-4de6-b6ff-02a2068ca1cb)

配置できたら、エディタ上でプレイしてループでも同じように表示されるかを確認します。  
もしループ時に表示されない場合は誤ってOsgs_Level_Topレベル上に配置してしまった可能性があります。その時はそのオブジェクトを削除し再配置してください。  

#### 進行状況の表示
進行状況表示（ラウンド数表示）はOsgs_BP_Actor_Round_TextRenderアクター（/Content/Osagashi/Blueprint/Actor/Round/Osgs_BP_Actor_Round_TextRender.uasset）で行っています。  

![配置しているOsgs_BP_Actor_Round_TextRenderの図解](https://github.com/user-attachments/assets/6058fd7f-3dfa-4b32-8289-aeb7cf2e3ad5)

サンプルでは参考として、進行状況に応じて棒も近くに表示させてもいます（Osgs_BP_Actor_Round_TextRenderアクターのCountActors変数）。  
これは作成するレベルの世界観やテーマによっては直接数字を表示をするのは合わないような時を想定したサンプルになります。  
例えば蝋燭が増えることで進行状況がわかるようになるといった表現が可能になります。  

またOsgs_BP_Actor_Round_TextRenderアクターのNumberActors変数では数字別のアクターを設定することも可能です。  
例えば全ての数字の画像をアクターとして配置し、それをNumberActors変数に設定して使用します。  

ただ細部にまで拘りすぎると慣れるまでは時間がかかりすぎるため、はじめは割り切ってシンプルに数字を表示するだけでも良いと思います。  

#### ゴールの作り方
ゴールにはOsgs_BP_Actor_Goalアクター（/Content/Osagashi/Blueprint/Actor/Goal/Osgs_BP_Actor_Goal.uasset）を使います。  
サンプルの「Goal!」と表示されたオブジェクトを参考にしてください（「Goal!」の文字はレベル作成時のみ表示され、プレイ中はゴールする時であっても表示されません）。  

![配置しているOsgs_BP_Actor_Goalの図解](https://github.com/user-attachments/assets/5f8c0a41-11aa-4840-b973-89cafbc7ecb0)

最低限必要なのはゴールした判定を取得するトリガーで、レベル内で選択し、詳細タブの［デフォルト > Triggers］に要素を追加してレベル上のトリガー用のアクターを選択する必要があります。  
サンプルではGoalTriggerアクターになります。  

ただトリガーだけではプレイヤーには視覚的にゴールであることが認識できないため、ShowActors（Show＝見せる）とHideActors（Hide＝隠す）で視覚的にゴールを作ります。  
サンプルではゴール可能時に表示するアクターと非表示にするアクターを設定しており、ゴール時は曲道にせず壁と床を追加して直線にして上り坂を表示しています（ShowActorsに設定）。  
そして不要な壁とラウンド数表示などをHideActorsに設定しています。  

レベル作成に慣れるまでは1つのレベル上に通常のルートとゴール用のルートを混在させるのは難しいかもしれません。  
そのような場合は、ゴール用のトリガーを大きくして設置し、その中央あたりにゴールっぽいオブジェクトを配置するだけでも良いかもしれません。  

なおゴール時に表示されるUIはOsgs_WBP_Endingユーザーウィジット（/Content/Osagashi/UI/Ending/Osgs_WBP_Ending.uasset）になります。  
これをカスタマイズすることでクリア時のUIを変更することが可能です。  

#### 【重要】Osgs_BP_LevelHelper_MainStageアクター
Osgs_BP_LevelHelper_MainStageアクター（/Content/Osagashi/Blueprint/LevelHelper/Osgs_BP_LevelHelper_MainStage.uasset）はプレイヤーがどこを通過したかをチェックして、お探しループゲームを運用しているとても重要なアクターです。  

![配置したOsgs_BP_LevelHelper_MainStageの図解](https://github.com/user-attachments/assets/d9a32ed6-7ffa-41b9-8e9d-45eec47eafa1)

下手に弄るとバグの発生に繋がりやすいので、わからないで編集することがないように注意してください。  
進行先のレベル生成などが正常に行われなくなる恐れがあります。  

##### 入口と出口の場所
Osgs_BP_LevelHelper_MainStageアクターのFrontStageTransform変数とBackStageTransform変数で、レベルの入口と出口の起点となる場所を設定しています。  

動的に進行先にレベルを生成してループを実現している関係上、入口と出口の位置は非常に重要です。  
ここがズレるとループ時に道がズレて表示されますし、ズレが大きいと視覚的に不自然になるだけでなく先に進めなくなる恐れもあります。  

慣れるまではサンプルの床と壁を装飾する感じ（オブジェクトで覆い隠す）にし、位置は動かさない方が失敗しにくいと思います。  

入口の起点はBackStageTransformNoteアクターで、引き返す際にここを起点に同じレベルが生成されて表示されます。  
入口の位置はXYZの座標がすべてゼロ（回転のZ軸が180なのは、引き返す時は道を逆側に生成するため）とわかりやすいので、基本的にレベルの寸法を変更する場合は出口側を移動させると良いでしょう。  

![配置しているBackStageTransformNoteの図解](https://github.com/user-attachments/assets/32a3eaea-cb96-4bb3-9f1d-be58dc26142e)

出口の起点はFrontStageTransformNoteアクターです。  

![配置しているFrontStageTransformNoteの図解](https://github.com/user-attachments/assets/dbd5ab58-24b0-4ad9-86c8-c5a29812d7ed)

##### 3種類のトリガー管理
Osgs_BP_LevelHelper_MainStageアクターでは重要なトリガーを管理しており、ここをプレイヤーが通過すると自動的に処理を実行します。  
これらはのトリガーはレベルの出入口に配置しており、各3つの計6つのトリガーがあります。  

![3種類のトリガーの配置位置の図解](https://github.com/user-attachments/assets/f879a8bc-d797-4b95-b645-8245a51a27d3)

* Entryトリガー（レベルに入ったことを管理し、フラグ有りの時はこれに触れた時にレベルに変化が現れる）
* Answerトリガー（引き返したか引き返さなかったかを、プレイヤーがこれに触れた時に判断）
* Stageトリガー（プレイヤーがこれに触れた時に、その先のレベルを生成してループを実現する）

これはゲーム進行に重要なトリガーなため、不用意に弄るとバグの原因になります。  

##### 引き返したかどうかで発見したかどうかの設定
* FrontToFoundAnswer変数
* BackToFoundAnswer変数

![Osgs_BP_LevelHelper_MainStageの回答設定用変数の図解](https://github.com/user-attachments/assets/c091753f-be28-47f6-be2b-5e207df60312)

サンプルゲームではどちらに進んでも見つからなかったとするため、どちらの変数も初期値はfalse（チェック無し）になっています。  
例えば、8番出口のように「見つけたら引き返す」というルールなら、BackToFoundAnswer変数をtrue（チェック有り）にします。  

##### その他の管理
重要なトリガー管理の他に、補助的に2つを管理しています。  
これら2つは無くてもゲームの進行には影響しません。  

* SalvageTriggers変数（想定外のルートを通りプレイヤーが落下した時などにリスポーンさせるためのトリガー）
* NotFoundsGuidePlayerTransform変数（クリア後に見つかっていないモノの案内板の前にスポーンさせたい時のスポーン先の設定）

SalvageTriggers変数は例外処理的な救済処置のようなもので、よくわからない時は未指定でも良いと思います（ゴミ箱アイコンのボタンを左クリックして0配列エレメントにする）。

NotFoundsGuidePlayerTransform変数はスポーン場所によっては想定外のフラグが発生することありバグの原因になることがあるので、クリア後のゲーム進行に問題が発生するような時はクリア後のスポーン先変更を諦める判断をしてください（対応・修正は上級者向けのため）。  
基本的にはEntryトリガーの内側にする必要があります。そうしないと進行先にレベルが読み込まれずループできないバグの原因になり、それを回避するのはプログラムの追加が必要になります。  
クリア後のスポーン先を変更しない場合は、NotFoundsGuidePlayerTransform変数を「なし」（選択肢から「クリア」を左クリック）にしてください。  

#### Osgs_Level_Topレベル
これまでは主にループに使用するOsgs_Level_MainStageレベル上の話でしたが、このゲームの大本となるトップレベルであるOsgs_Level_Topレベル（/Content/Osagashi/Level/Osgs_Level_Top.umap）について説明します。  
ここでは重要なものが3つあります。  

* Osgs_BP_LevelHelper_Topアクター（トップレベルであるOsgs_Level_Topレベルを管理するアクター）
* ループするレベルのインスタンス（サンプルではOsgs_Level_MainStageレベル）
* PlayerStart（起動時にプレイヤーがスポーンされる場所）

![Osgs_Level_Topの図解](https://github.com/user-attachments/assets/bf2ec1a6-ead5-4971-9994-e2045dbad07a)

レベル上のOsgs_BP_LevelHelper_Topアクター（/Content/Osagashi/Blueprint/LevelHelper/Osgs_BP_LevelHelper_Top.uasset）のStartLevelInstance変数にはループするレベルのインスタンスであるレベル上のOsgs_Level_MainStageレベルインスタンスを設定しています。  
これにより新たに生成された別レベルに入った時に不要になったループ用のレベルとして非表示になります。  

PlayerStartはサンプルを参考に2つのEntryトリガーの間になるように配置し、どちらに進んでもどちらかのEntryトリガーに触れるようにしてください。  
そうしないとループ先のレベルが生成されません（Entryトリガーに触れないとStageトリガーが無視される）。  

##### BGMの設定
サンプルゲームは環境音すらなく無音のため、可能であれば環境音やBGMを追加しましょう。  

まずはフリー音源サイトなどから入手したサウンドファイルをわかりやすいフォルダにインポートしておきます（Wav形式などの一部の音楽フォーマットにしか対応していません）。  
そしてレベル上のOsgs_BP_LevelHelper_Topアクターを選択し、詳細タブの［デフォルト > Sound］にそのインポートしたファイルを設定しましょう。  

![Osgs_BP_LevelHelper_TopへのSoundファイルの設定個所の図解](https://github.com/user-attachments/assets/312627b6-422c-494c-97d0-4ccf2f6ac123)

ここで使用する音源はループ設定しておいてください。  
エディタ上で開き、詳細タブの［サウンド > Looping］を有効（チェックを入れる）にします。  

![サウンドウェーブのループ設定個所の図解](https://github.com/user-attachments/assets/426ceb35-9b15-4e95-acbf-355f7c5942fe)

なおループ感覚の調整を行うには、そのサウンドファイルをサウンドキューやMetaSoundとして設定すれば可能ですが、ここでの説明は割愛します。  
Unreal Engineに慣れるまではインポートするサウンドファイルの後ろに無音を挿入してループの間隔を調整する方が簡単と思います。  

#### レベルを完成させよう
レベル編集の基本がわかれば、後はシティシム感覚でレベル作っていくだけです。  

とりあえずUnreal Engine公式アセットストアであるUnrealマーケットプレイスから無料アセット（3Dモデル）を入手してそれらを配置してみましょう（このマーケットプレイスからダウンロードできるアセットには無料のものも含めゲーム素材として使ってよいライセンスが付与されています）。  
または[RealityScan](https://www.unrealengine.com/ja/realityscan)でスマホのカメラなどでスキャンしたものを3Dモデルとして取り込んでも良いでしょう（フリーゲームとして公開するつもりであっても漫画の違法コピーと同様にフィギュアなどの使用には著作権上の問題が発生する恐れがあるため注意してください）。  

使用する3Dモデルによっては当たり判定がなくプレイヤーが通り抜けてしまうものがありますが、このような場合はコリジョンの設定を変更してみてください。

まずはシティシム感覚で地形作り・建物建築を楽しんで、お探しゲームであることを忘れて自分が作るレベルを散歩してみても良いでしょう。  
最悪サンプルゲームが正常に動作しなくなっても、サンプルを新たにインストールしなおせば良いので、失敗から学ぶつもりで恐れず色々と挑戦してみましょう。  

なおサンプルゲームでフラグや進行状況に応じて表示の制御が行われているオブジェクトは、削除しようとしても参照されているオブジェクトとしてメッセージが出ると思いますが、この時は削除をキャンセルしてください。  
それにステップ3のフラグ設定の時の参考にもなるかもしれませんから、邪魔にならない場所にでも移動させておいてください。  

それとゲーム開発を一通り経験して全体を理解することも大切なので、はじめはあまりレベル作成に拘らずに次のステップに進んでも良いと思います。  

##### サウンドを配置するには
BGMではなく配置するオブジェクトが発する音も、3Dモデルなどと同様にサウンドファイルを配置することができます。  
サウンドも3Dモデルなどと同様にフラグ設定することで再生の有無を切り替えることができます。  

ただし、単純にレベル上に配置しただけではプレイヤーキャラクターの位置に関係なく聞こえてしまうので、減衰設定を行います（立体音響となり音の位置とプレイヤーキャラクターの位置に応じて音量も変化させる）。  

まず配置したサウンドファイルを選択し、その詳細タブの［アテニュエーション > OverrideAttenuation］を有効（チェックを入れる）にします。  
これを有効にすると［減衰（ボリューム）］が表示されるようになるので、[公式ドキュメントのサウンドの減衰](https://dev.epicgames.com/documentation/ja-jp/unreal-engine/sound-attenuation-in-unreal-engine)などを参考に、［減衰関数］［減衰最短距離］［フォールオフ距離］などを調整します。  
わからなければ［減衰関数］を「Natural Sound」（自然な減衰処理）にし、［減衰最短距離］と［フォールオフ距離］をそれぞれ「400」前後にすると良いでしょう。特にフォールオフ距離の初期値が大きく、初期値のままだとループ先でも音が聞こえてしまう恐れがあります。  

![レベル上のオーディオファイルの減衰設定個所の図解](https://github.com/user-attachments/assets/d3b956c4-2d77-4c10-b8ad-fb0550c26cde)

なお減衰設定はサウンドオブジェクト毎に個別に設定せず、ファイル化して減衰設定を共通化できもしますが、ここでは割愛しています。  

また配置するサウンドファイルはBGMと同様にループ設定を有効にした方が良いでしょう。  

## 【ステップ2】 フラグリスト作成
フラグリストはOsgs_DataTable_Flagsデータテーブル（/Content/Osagashi/Findloople/Osgs_DataTable_Flags.uasset）になります。  

![Osgs_DataTable_Flagsの編集画面の図解](https://github.com/user-attachments/assets/43329012-0163-4e60-9bdb-8d7ba4c6548f)

* 行の名前（特に使わないので連番でも良いですが、他の行と重複したものは使えません）
* Active（False=チェック無しのものはフラグとして使われません）
* ID（フラグIDでフラグ有りの時は抽選されたこのIDを元に制御を行う）
* Name（メニュー画面などに表示されますが、名前でネタバレを避ける場合は抽象的にすると良いでしょう）
* Discription（メニュー画面の一覧に表示される説明・補足）
* Tags（Flag.Tag.Difficultを指定したフラグは、終盤に優先的表示されやすくなる）

サンプルゲームのこのフラグリストを参考に、作成したレベルにあったフラグを追加していきます。  
作ろうとするゲームがかくれんぼ系や「ウォーリーをさがせ！」なようなものか、8番ライクのような異変探しかなどでフラグは変わってくるとは思います。  
使わないフラグはActiveのチェックを外せば良いので、まずはアイデア出しのつもりでどんどん思いつく限り追加していくと良いでしょう。  

重要なのはIDで、このフラグIDで管理・制御を行います（Active=Falseのチェックが無いものは除く）。  
また他の行と重複する場合はそのうちの1つしか有効にならないので注意してください。  

デフォルトではNameとDiscriptionはゲーム内メニューに表示されますが、その表示個所やボタンを非表示にカスタマイズすることは可能です。  
ただNameは開発中のテストプレイ時に抽選されたフラグとして画面の左上に2秒ほど表示され便利なので、区別できるようにしておきましょう。  

### フラグID
フラグIDにはUnreal Engineのゲームプレイタグ（Gameplay Tag）を使います。  

![ゲームプレイタグの選択・追加の図解](https://github.com/user-attachments/assets/9738a2c7-475b-448b-b2ab-3221d7fcfe14)

IDの横にある下矢印のボタンを左クリックしてメニューを開き、フラグIDにチェックを入れます。  
基本的には新しいフラグはIDを追加することになるはずので、［新しいゲームプレイタグを追加］ボタン（緑色のプラスアイコン）を左クリックします。  
そうすると「名前」「コメント」「ソース」の欄が表示されるので、名前欄に新しいフラグIDを入力します。  

フラグ設定の際に使うので、わかりやすいIDが良いです。  
書式としては「Flag.ID.」＋「（わかりやすい名前）」が良いでしょう（書式は自由なので、必要に応じて変更も可能です）。  

例えばリンゴ関連のフラグであれば「Flag.ID.Apple」。
もしリンゴ関連のものが複数あるなら、「Flag.ID.Apple.Big」（大きいリンゴ）と「Flag.ID.Apple.Rotate」（回転するリンゴ）などにすると良いでしょう。これにより「.」（ピリオド）でグループ化され「Flag.ID.Apple」に「Big」と「Rotate」のタグという形になり便利です。  
もちろん好みで「Flag.ID.BigApple」「Anomaly.ID.RotateApple」としても良いです。  

また他に作るフラグによっては「Flg.ID.Big」や「Flag.ID.Move」でグループ化した方が便利な場合もあるでしょうから、ご自身で判断してください。  

コメントに関しては任意で空白のままでも問題はありません。  

そしてソースは特に理由がなければ「Flag.ini」にしておくのが良いでしょう（ゲームプレイタグさえ使えれば良いので別のソースで管理することも可能です）。  
この時、ソース欄右側のお気に入り（星マーク）を有効にしておくと、次回からFlagIDを追加する時に自動的に同じソースを選択済みにしてくれるようです。  

「名前」と「ソース」の入力が完了したら、それらの下に表示されている［新しいタグを追加］ボタンを左クリックします。  
追加後はそのIDにチェックを入れ選択します。  

### Tags
ゲームの終盤に抽選対象としたいフラグの場合は、Tagsの「Flag.Tag.Difficult」にチェックを入れます。  
このタグを持ったフラグは、終盤に優先的に発生するようになります。  

![フラグリストにDifficultタグを設定する方法の図解](https://github.com/user-attachments/assets/f3d432bb-8c78-4319-9d89-ec6d24c5fa8b)

例えばトラップ系や高難易度のフラグに設定します。  
ゲームの難易度調整目的以外にも、わかりやすいものを序盤に発生しやすくするために、それ以外に設定するという使い方もあります。ゲーム開始直後は簡単に進めるようにすることで、プレイヤーの気持ちを盛り上げれるかもしれません（ただし終盤にわかりやすい異変が出にくくなるのでご自身で判断してください）。  

なおこの終盤発生用タグはOsgs_BP_FlagMasterブループリント（/Content/Osagashi/Findloople/Osgs_BP_FlagMaster.uasset）のDifficultTag変数で設定されたものが使用されます。  

### フラグIDの削除
サンプルのフラグIDや誤って作成してしまったフラグIDなどは、ゲームプレイタグマネージャーから削除できます。  
ゲームプレイタグ選択メニューの［ゲームプレイタグを管理］ボタンから表示可能です。  

なお未使用のフラグIDがあっても、フラグリストのActiveが有効（チェック有り）のものしか使われないため、削除しなくても特に問題はありません（フラグ設定の際に、誤って使っていないフラグIDを設定してしまうリスクはあります）。  

## 【ステップ3】 フラグ設定
フラグ設定にはOsgs_BP_FlagActorアクター（/Content/Osagashi/Findloople/Osgs_BP_FlagActor.uasset）を使います。  

ここでは例としてサンプルのアルファベットオブジェクトが1つ消す場合で説明していきます（例えばサンプルの「消えたドア」フラグでは、ドアを消し、そのドアがあった場所にステッカーを表示させています）。  
フラグリストに練習用のフラグを追加しても良いですし、一時的に他のフラグIDを流用しても良いです。  

### Osgs_BP_FlagActorアクターをレベルに追加する
まずはOsgs_BP_FlagActorアクターをOsgs_Level_MainStageレベルに配置します。  

![Osgs_BP_FlagActorを配置する（メモ含む）図解](https://github.com/user-attachments/assets/eba9e767-5eff-4df7-a66b-e7bbb346896e)

#### メモを書く
フラグID毎に追加することになるので、どのフラグを担当するかがわかりやすいように追加したOsgs_BP_FlagActorアクターを選択状態にし、そのアクターの［詳細］タブの［MemoText］変数に「アルファベットの変化」のようにメモを入力します。  
このメモは開発用でプレイ中は表示されません。  

#### フラグIDを設定する
次にその［詳細］タブの［Flags］変数の要素追加ボタン（プラスマーク）を左クリックして項目を追加し、このフラグのフラグIDを選択します。  

![Osgs_BP_FlagActorにフラグIDとHideActorsを設定する図解](https://github.com/user-attachments/assets/97603cf3-fbf3-4575-9928-234693d93edb)

#### HideActorsを設定する
今回はアルファベットを消すので、［詳細］タブの［HideActors］変数（Hide＝隠す）を使います。  

この変数の要素追加ボタンを左クリックして項目を追加します。  
追加した項目のアクタ選択ボタン（スポイトマーク）を左クリックした後、レベル上の非表示にしたいアルファベットオブジェクトを左クリックします。  

これで抽選されたフラグIDがここで設定したフラグIDだった時に、［HideActors］変数に設定されたオブジェクトが非表示になります。  
そのため誤って別のオブジェクトを選択すると、そのオブジェクトが非表示になってしまいます。  

なお複数のオブジェクトが重なってスポイトで選択できないような時は、リストから選択することもできます。  

#### 応用編 ShowActorsを設定する
もし消えるのではなく移動させる場合は、非表示にするオブジェクトを複製して別の場所に移動させます。  

![Osgs_BP_Actor_Anomalyで移動する異変を設定する図解](https://github.com/user-attachments/assets/619cd414-ff72-4997-94ad-347e6b4253e6)

そして［詳細］タブの［ShowActors］変数（Show＝見せる）に要素を追加し、複製した移動した先となるオブジェクトを選択します。  
これで元の場所のオブジェクトが非表示になり、複製した移動後のオブジェクトが表示されるようになります。プレイヤーからはオブジェクトが消えたのではなく移動したように見えます。  

オブジェクトを移動させるのではなく大きさを変えることもできます。  

この要領で表示非表示の切替だけでもアイデア次第で色々なことができます。  
例えば、本を移動したように見せ、本があった場所に小さなステッカーを表示することで、小さいステーカーが表示されるだけだとしても本を移動したように見せることでヒントとして見つけやすくなります（変化を活用することで多少の難易度調整も可能です）。  

#### 写真撮影用のアクター
サンプルゲームではステッカーを見つけたらそれを写真に撮るルールになっています。  
これにはOsgs_BP_Actor_Answerアクター（/Content/Osagashi/Blueprint/Actor/Answer/Osgs_BP_Actor_Answer.uasset）を使います。  

もし8番出口のように見つけたら引き返す・見つからなかったら引き返さないというルールであれば、このOsgs_BP_Actor_Answerアクターは不要です。  
Osgs_BP_LevelHelper_MainStageの引き返したかどうかで発見したかどうかの設定をするだけです。  

引き返す・引き返さないかだけの方が作るのも楽ですし、プレイヤーにとってもルール的にも操作的にも楽だと言えます。  
これに関してはゲームのルール・コンセプト・世界観によって向き不向きはあると思います。  
例えば「〇〇参上！」みたいな落書きや除霊用のお札を探すゲームであれば、危険なので引き返すというのは自然かと思います。他にも警察・刑事を見つけたら引き返すなどアイデア次第です。  

![Osgs_BP_Actor_Answerをレベル上に配置する図解](https://github.com/user-attachments/assets/a9ae9bba-2a85-43c7-b0e7-881a395b1f31)

まずはOsgs_BP_Actor_Answerを写真撮影の中央に配置します。
この際にOsgs_BP_Actor_AnswerのMemoText変数にわかりやすいメモを入力しておくと良いでしょう。  

そして先程の要領で、このOsgs_BP_Actor_AnswerをOsgs_BP_FlagActorのShowActorsに設定します。  
これにより、そのフラグが立った時にこのOsgs_BP_Actor_Answerが動作し、写真撮影した場合に「見つけた」として回答されるようになります。  

なお正しく写真撮影しているかどうかはプレイヤーの距離や角度で判断しているため、高い位置を撮影させるような場合はパラメーターの調整が必要です。  
* OverrideMaxVisioDistance変数…プレイヤーとの距離で、基本的にはこのパラメーターの調整だけで良いでしょう（運で正解する可能性が少し高くなってしまっても、撮ったつもりで撮れていなかったストレスを抑制するためにも余裕を持たせた数値で良いと思います）。  
* OverrideTargetAngle変数…黄色い細い矢印を起点に、どの角度から見られているかを調整できます（基本的には全方位となる「360.0」で良いと思います）。  
* OverridePlayerAngle変数…プレイヤー側の視界が何度まで入っているかで、大きいと画面（カメラ）に映っていなくても撮影成功した判定になってしまいます。  

![Osgs_BP_Actor_Answerの各種パラメーターの図解](https://github.com/user-attachments/assets/4f62f507-7155-4398-a1a0-f84c81381ad2)

それと撮影成功時に特定のオブジェクトを表示非表示することもできます。  
例えばステッカーを剥がしたり、落書きを消したりするコンセプトのゲームなどに使います。ビックリ演出として何かを表示するといった使い方も可能です。  
* HideActors変数…撮影成功時に非表示にするオブジェクト
* ShowActors変数…撮影成功時に表示するオブジェクト

サンプルでは汎用性が高い写真撮影にしていますが、Osgs_BP_Actor_AnswerをカスタマイズすることでUIを変更したり、ステッカーを剥がしたり、落書きを消したり、攻撃したりといったものに変更することも可能です。  

### フラグのテスト
設定したフラグは、エディタ上でプレイして想定通りに動作するか確認しましょう。  

![ギャラリー設定の場所の図解](https://github.com/user-attachments/assets/15d3a871-7cf4-4ace-975b-9cce2081c20d)

ゲーム内メニュー下部中央のギャラリー設定からテストしたいフラグを指定することで強制的にそのフラグを発生させることができます。  
なお、0ラウンドの抽選確率が0以下だとラウンド1にならないと抽選自体行われません。ただフラグがない状態では何も起こらないことを確認することも必要なため、そのチェックも忘れないようにしましょう。  

抽選後はデバック情報として画面左上に抽選した異変名が2秒ほど表示されるのでそこも見るようにしましょう（開発中のみ表示されます）。  

![デバッグ情報の表示例の図解](https://github.com/user-attachments/assets/9f0f5840-7b73-4650-9165-3625f7be556b)

また見つかっていないフラグの間（フラグが発生した時にフラグ有りとして回答するまで）は、ギャラリー設定などにフラグ名は表示されません（フラグ名によるネタバレ防止のため）。  
フラグの番号はフラグリストの上から連番になっているため（Activeが無効なものとフラグIDが重複しているものを除く）、見つかった状態になるまではその番号で指定することになります。デバッグ情報として抽選したフラグ名が表示されるので、そこで正しくフラグを指定できているかが確認できます。  

## 仕上げ
エディタ上で最初から最後までプレイでき、クリア後の全フラグ回収なども含めてバグが見つからなければ、一応はゲームが完成したと言えます。  

もし参考用に残している不要なサンプルのオブジェクトなどがあれば削除します。  
基本的にサンプルで使っているOsgs_BP_FlagActorアクターは何かしらのオブジェクトを参照（HideActorsやShowActorsとして）しているので、先にOsgs_BP_FlagActorアクターを削除すると削除の際にメッセージが表示されないと思います。  

念のため、誤って削除したオブジェクトないか最後にテストしておいた方が安心です。  

### ゲーム情報の書き換え
ゲーム公開前にゲームタイトルなどを自分のゲーム用に書き換えます。  

ゲームタイトルに関しては商標登録の有無に関係なく、ライク作品では本家の続編などと誤認させる恐れがあるものは避けましょう（例えば「N番出口」など）。  
続編と誤解してプレイする人がいるだけでなく、誤解したまま本家の開発者さんにクレームが行くケースなども普通にありえます（よく確認もせず、勘違いしたままクレームするようなヤバい人も少なくありません）。  

それとゲームタイトルがシンプルだと検索した時に埋もれてしまうことがあるので、短い単語の組み合わせの時は工夫した方が良いかもしれません。  
またセンシティブな単語が含まれるとYouTubeなどでは不都合があるため、ゲーム実況を想定する場合はその点にも注意が必要です。  

#### プロジェクト設定
エディタ上部のメニューの［編集 > プロジェクト設定］を左クリックし、プロジェクト設定の［プロジェクト > 説明］を開き、［Unreal Editorについて > プロジェクト名］と［表示 > プロジェクトが表示されたタイトル］にゲームタイトルに入力します（ゲーム起動時のウィンドウ名に使用される）。  

なお、［Unreal Editorについて > プロジェクト名］はWindowsのタスクマネージャーのアプリの表示で影響があるようです。  
他の項目は特に変更しなくても問題ないかもしれませんが、［Unreal Editorについて > プロジェクトバージョン］が未入力だとパッケージ化の際などにエラーが発生し失敗するようです。  

![プロジェクトが表示されたタイトルの設定個所（プロジェクトバージョン含む）の図解](https://github.com/user-attachments/assets/3fbd234f-e743-49e4-8028-153984f5fe9b)

### Osgs_BP_FunctionLibrary
* Title（ゲームタイトル）
* Version（バージョン）
* Copyright（著作権表記）
* Year（リリース年）

ゲーム内ではこれらの情報がOsgs_BP_FunctionLibrary（/Content/Osagashi/Blueprint/Osgs_BP_FunctionLibrary.uasset）のGetGameInfo関数のReturnNodeにまとめているので、ここも書き換えてください。  

![Osgs_BP_FunctionLibraryのGetGameInfo関数の編集箇所の図解](https://github.com/user-attachments/assets/9ff9fca1-b674-46bc-a27a-f5546c650049)

バージョンはリリース時に「ver.01.00.00」としておき、ちょっとした修正のアップデートであっても、その都度バージョンを繰り上げておくと不具合に関する問い合わせがあった時などの確認に便利です。  

#### クレジット表記
GetOtherCredit関数のReturnNodeのReturnValueにクレジット表記を入力しておくと、ゲーム内メニューのインフォメーションのクレジットタブと、クリア時に表示されるUIに自動的に表示されます。  

公式ストアであるUnrealマーケットプレイスで入手したアセットは特に必要ないのですが、フリー音源などをゲーム素材に使用する場合は規約に従ってクレジット表記などが必要になる場合があります。  
フリー素材は規約に従った場合に無料で使えるものなので、規約を守らない場合は料金が発生したり著作権侵害など法的責任を問われる場合があるので注意してください。  

このゲームのテンプレート（MITライセンス）とUnreal Engineの表記はゲームタイトルとリリース年を元に自動表示しているので、特に問題がなければ編集せずにそのまま表示してください。  

なおライセンス表記・クレジット表記はゲーム内に表示しなくてもストアページでも良い場合もあるので、ゲーム開発初心者はストアページに表記する方が安心かもしれません（勝手に判断・解釈せず、使用する素材などの規約など確認してください）。  

### インフォメーションの概要
ゲーム内メニューのインフォメーションの概要の文言を変更する場合はOsgs_Advance_RichTextBlock_Info_Summaryファイル（/Content/Osagashi_Advance/UI/Info/Osgs_Advance_RichTextBlock_Info_Summary.uasset）の［コンテンツ > Text］を書き換えてください。  

簡単なゲームの説明やゲーム実況の許可などについて書いても良いでしょう。  
ただストアページ以上にゲーム内の説明を読まないプレイヤーは少なくないでしょうから、ゲーム内メニューをカスタマイズしてインフォメーションそのものをなくして（非表示）も良いかもしれません（このゲームのテンプレートとUnreal Engineのクレジット表記は、サンプルのままであればクリア時のUIに表示されるため）。  

# パッケージ化（配布用ファイル作成）
エディタ上で問題なくゲームを遊ぶことができても、このままでは他の人にプレイしてもらうには問題があります。  

特にアセットを使用している場合、無料アセットであってもプロジェクトファイルをそのまま配布するとライセンス違反の恐れがあります。  
基本的にアセットはゲームファイルに変換して再利用できない状態で配布する場合のライセンスが付与されています。  

そのため作ったゲームをパッケージ化して配布用のファイルを作成しなければなりません。  

Unreal EngineはWindowsだけでなく、MacやiOS（iPhone/iPad）、Android、PlayStation、Switchなど様々なプラットフォーム向けにパッケージ化できます。  
しかしどのプラットフォーム向けにパッケージ化するにしても、そのプラットフォーム向けに別途インストールするなどの準備が必要です。  

もしすでにUnreal Engineでゲームを開発していてパッケージ化の準備が完了しているのであれば、すぐにパッケージ化できるかと思います。  

ただパッケージ化に関してはこのゲームのテンプレート固有のテーマではないため、詳しいパッケージ化の手順などについては公式ドキュメントや動画などを参考にしてください。  

「UE5 パッケージ化」などのキーワードでネットや動画を検索してみてください。  
なおUnreal Engineのバージョンや開発環境がWindowsかMacなどかによって必要なものや手順が異なることがあるため、1つの情報だけでは上手くできない可能性があります。  

なおこのゲームのテンプレートはWindows11上で開発し、Windows向けにエラーも警告もなくパッケージ化でき、正常に動作することは確認できています。  
警告に関しては使用するアセットが起因するものもありゼロにできないこともありますが、警告があっても配布ファイル作成には特に問題はないと思います（エラーがある場合はパッケージ化が失敗すると思います）。  

もしパッケージ化が失敗する場合、まずはこのゲームのテンプレートを編集せずにそのままパッケージ化を試してみても良いかもしれません。  
この時点で失敗する場合はパッケージ化の準備が不十分であると考えられますし、成功する場合は編集した自作ゲーム側に問題があると考えられます。  

なおパッケージ化に関しては普通にプログラミングできる人でも苦戦することは珍しくない躓きポイントですので、上手くいかなくてもあまり気にする必要はありません。  
ゲーム開発者でもパッケージ化経験がない人は少なくないでしょうし、そもそもゲームを完成することなく頓挫することも珍しくはありません。  
そのためにパッケージ化に関する情報自体が少ないです。  

## パッケージ化の手順
Windows向けのパッケージ化の準備が完了している場合、次の手順でパッケージ化可能です。  
なお、細かい設定を行うことでパッケージ化したファイルを小さくしたり暗号化したりもできますが、ここでは割愛します。  

![パッケージ化ボタン位置の図解](https://github.com/user-attachments/assets/ec4141ae-d2d2-4af8-a5a9-69e646ff19e1)

エディタ上部中央の［プラットフォーム］ボタンを左クリックしてメニューを開き、［コンテンツ/SDK/デバイス管理 > Windows］を開きます。  
この時、［Windows］の前にビックリマークアイコンが表示されている場合はパッケージ化の準備が完了していないと思われます。  
そして［バイナリ コンフィギュレーション > シッピング］が有効（白い点）になっていなければ、それを左クリックして有効にしてください。  
［シッピング］が有効であれば、［コンテンツ管理 > プロジェクトをパッケージ化］を左クリックしてください。  
保存先のディレクトリを聞かれるので、パッケージ化用にわかりやすいフォルダを作って指定します。  

これでパッケージ化の処理がはじまります。  

パッケージ化時間はゲームの内容と開発端末性能（おそらくCPU性能）で大きく異なります。  
未編集状態のこのゲームのテンプレートであれば、AMD Ryzen 9 16コア環境で1分程度でした。
しかし過去に数世代前のCPUでゲーム開発していた時は、ゲームのサイズも数GBなのもあり初回のパッケージ化は10時間程掛かりました（2回目以降は数十分に短縮されました）。

完了後は成功しても失敗しても音で通知してくれるはずです。  

パッケージ化が成功していれば、指定したフォルダに「Windows」フォルダができていて、その中に配布用ファイル一式がまとめっていると思います。
配布する時はそのWindowsフォルダをZIP化するなどして公開すると良いでしょう（Steamなどのストアで公開する時は、ストアの指示に従ってください）。  

![パッケージ化で作成されたファイル一式の図](https://github.com/user-attachments/assets/624dbad1-fa4b-430c-b109-04bc170282b5)

設定などを変更していなければ「Findloople.exe」をダブルクリックすればゲームが起動するはずです。  
実は恐ろしい話ですが、エディタ上では問題なく動作していても、パッケージ化すると動作しなくなることは珍しくなく、配布用のファイルでもテストプレイが必要です（ゲームエンジンそのものにもバグはあるのです）。  

### ゲームの実行ファイルのアイコン
初期設定ではパッケージ化したゲームのEXEファイルのアイコンはUnreal Engineのマークになっています。  

これを変更する場合はエディタの「プロジェクト設定」の［プラットフォーム > Windows > Icon > ゲームアイコン］を変更するだけです。  
ファイル形式はIcoファイル（*.ico）ですが「PNG Ico 変換」などで検索すれば無料でファイル変換してくれるサービスが見つかるかと思います。  
画像の寸法は256pxの正方形のようです。  

# 【注意】テンプレートのアップデート（中級者・上級者向け）
テンプレートのアップデート手順は、最新のテンプレートで新規Unrealプロジェクトを作成し、旧プロジェクトの編集したファイルを新プロジェクトに移行（上書き）します。  

そのため編集した移行対象のファイルがアップデートで更新されたファイルだった場合は、アップデートできない可能性があります。  
またアップデート内容によってはアップデートできない可能性があります。  

アップデートする前に編集したUnrealプロジェクトはバックアップを取ってください。  
簡単にバックアップを取る方法としては、エディタ上部の［ファイル > プロジェクトをZIP圧縮］からZIPファイルを作成する方法です（未編集のテンプレートをZIP圧縮すると10MB未満だと思いますが、サイズは追加したアセットなどによっては10GBを超える可能性は十分にあります）。  

## エディタ上で旧プロジェクトから移行するファイル
次のファイルを移行します。  
* フラグリスト…/Content/Osagashi/Findloople/Osgs_DataTable_Flags.uasset
* トップレベル…/Content/Osagashi/Level/Osgs_Level_Top.umap
* メインステージレベル…/Content/Osagashi/Level/Osgs_Level_MainStage.umap

他にも編集したファイルや新規作成したファイルがあればそれらも移行します。  
ただし編集したファイルがアップデートにより更新されていた場合はアップデートできない可能性があります（不具合が発生する恐れがあります）。  

移行する前に、もし新プロジェクトを開いている場合は閉じてください。  

そして移行するファイルが入った親フォルダを選択して右クリックし、表示されるメニューの［移行］を左クリックします。  

![移行メニュー（アセットレポート）を表示する手順](https://github.com/user-attachments/assets/dd636719-fa09-4c46-852e-1871a0c616c2)

アセットレポートが表示され、参照関係にあるファイルが全てチェック有り状態（移行対象）でリストアップされます。  
一旦、それらのチェックをすべて外し（最上位のチェックを外す）、移行するファイルのみにチェックを入れ、［OK］ボタンを左クリックします。  
なお、余分なファイルにチェックが入っていると、旧プロジェクトのアップデート前の古いファイルで上書きされてしまいます。  

![アセットレポートの図解](https://github.com/user-attachments/assets/b53a3882-d6f8-456e-b7b7-2deab54398e3)

送り先コンテンツフォルダを選択するウィンドウが表示されると思うので、新プロジェクトフォルダ直下の「Content」フォルダを選択します。  
上書き確認メッセージが表示された場合は、［すべてに適用］にチェックを入れ、［はい］ボタンを左クリックします。  

なお移行するファイルや端末のスペックによっては移行に時間がかかることがあります。  
また移行完了の通知は表示されないこともあります。  

## エクスプローラーで旧プロジェクトから直接移行（上書き）するファイル
フラグIDを登録しているFlag.ini（\Config\Tags\Flag.ini）はエディタ上では移行できないようなので、エクスプローラーで直接ファイル操作して上書きします。  
旧プロジェクトフォルダのFlag.iniファイルを、新プロジェクトフォルダのFlag.iniにコピー&ペーストもしくはドラッグ&ドロップします。  

## 新プロジェクトを開く
ファイルの移行が完了したら旧プロジェクトを閉じ、新プロジェクトを開きます。  
新プロジェクトが旧プロジェクトと同様に編集・プレイできるようであればテンプレートのアップデート作業は完了です。  

もし正常に動作しない場合は、ファイルの移行の失敗かファイルの上書きではアップデートできないと思われます。  
後者の場合、かなり上級者向けのため、基本的にはアップデートを諦めることになります。  

# 応用編

## 国際化（多言語対応）
Unreal Engine標準の[ローカリゼーションダッシュボート](https://dev.epicgames.com/documentation/ja-jp/unreal-engine/localization-tools-in-unreal-engine?application_version=5.4)を使ってゲーム内メニューの国際化に対応しています（エディタ上部の［ツール > ローカリゼーションダッシュボート］を左クリックして開けます）。  
ただしローカリゼーションダッシュボートは実験段階の機能のため、不具合が発生しやすかったり、Unreal Engineのアップデートで大幅な仕様変更が行われる可能性もあります。  

ゲームを国際化対応する場合、フラグリストに追加したフラグの名称や説明・詳細をこのローカリゼーションダッシュボートを使って翻訳したものを追記していく必要があるかもしれません。  

国際化対応が難しかったり負担が大きい場合は、割り切って国際化はあきらめても大きな問題はないでしょう。  
国際化対応を行わない場合は、ゲーム内メニューと環境設定にある言語設定の項目を非表示にしてください。  

なおエディタ上で言語の切替の動作確認を行う場合は「スタンドアローンゲーム」としてプレイする必要があるようです（これ以外のモードでテストしてしまうとエディタの表示言語が変更されてしまう恐れがあります）。  
またパッケージ化した場合に国際化が正常に動作しないこともあるため、パッケージ化後にも正常に動作するかテストした方が良いでしょう。  

ちなみに日本語のテキストも日本語に翻訳可能なため、分散しているテキストを一括で編集できる機能としても活用できなくもありません。  

## 8番ライクの作り方
サンプルゲームはステッカーを見つけたら写真に撮るお探しゲームです。  
これを異変（ステッカー）を見つけたら引き返す、見つからなかったら引き返さないという、典型的な8番ライクなゲームに変更する手順を説明します。  

8番ライクな仕様に設定変更できれば、異変探しゲームとして作っていくだけです。  

### 8番ライク向けにルール変更
[お探しループゲームのルール設定](#お探しループゲームのルール設定)を参考に、8番ライク向けにルール設定を変更します。  
参考として本家「8番出口」ぽくすると次のようになるかと思います（8番出口とまったく同じ仕様にはならないので、お好みで変更してください）。  

* LastRound=8（8番出口がゴール）  
* MustNoFlagLastRoundEndCondition=True（チェック有り。ラストは異変無しでないとクリアできない）  
* BaseProbability=0.5（基本の異変発生率50%）  
* ZeroRoundProbability=0.0（0番の時は異変無し固定）  
* LastRoundProbability=0.8（ラストの異変発生率を上げることで難易度が上がり、かつ体感的にそれまでの異変発生の低さをカバーできる）  
* PermissileNoFlags=3（連続異変無し許容回数で、8番出口は3回らしい）  
* Mode=Standard（失敗時0に戻る）  

### 写真撮影機能を無効化
Osgs_BP_GameModeブループリント（Content/Osagashi/Blueprint/GameMode/Osgs_BP_GameMode.uasset）を開きます。  
そして左側の［コンポーネント］タブ内の［AnswerComponent］を選択し、右側に表示される［詳細］タブの［デフォルト > UserWidgetClass］を［None］にします（バツボタンを左クリックしてクリアすると簡単です）。  

![Osgs_BP_GameModeのAnswerComponentの編集箇所の図解](https://github.com/user-attachments/assets/3ca70012-e149-403a-aadd-7fd02caa0f3d)

これにより写真撮影用のUIも表示されなくなります。  

### 引き返したら異変を見つけたことにする
[引き返したかどうかで発見したかどうかの設定](#引き返したかどうかで発見したかどうかの設定)を参考に、BackToFoundAnswer変数をTrue（チェック有り）に変更します。  
これによりサンプルゲームの写真撮影の代わりに、引き返しただけで異変を見つけたとして処理されるようになります。  

### 8番ライク用にテキストを変更
サンプルゲームのテキストは主に「見つかったモノ」といった感じの抽象的な言い回しなため、8番ライク・異変探し向けに変更する方が良いでしょう。  

ただテキストは分散しており、これからを個別に変更するのは多少手間がかかります。  
そこで国際化対応のローカリゼーションダッシュボートを活用し、日本語（「見つかったモノ」）を日本語（「見つかった異変」）に翻訳して対応する方法をご紹介します。  

![ローカリゼーションダッシュボートで日本語を日本語訳するための図解](https://github.com/user-attachments/assets/a91fce97-264b-4e33-9686-3264ec0071dd)

エディタ上部の［ツール > ローカリゼーションダッシュボート］を左クリックしてローカリゼーションダッシュボートを開きます。  
そして［ゲームターゲット］の「Osagashi」を左クリックし、［Osagashi］タブの［カルチャ］の［テキストを収集する］ボタンを左クリックします。  
自動でテキスト収集が行われ、完了後は［OK］ボタンが表示されるのでそれを左クリックして閉じます。  

![ローカリゼーションダッシュボートでテキスト収集する図解](https://github.com/user-attachments/assets/b3948c56-45f4-43b7-b83c-a31bf5a3a70c)

テキスト収集後は日本語行のアクション列の左端にある［このカルチャーの翻訳を編集］ボタンを左クリックし、翻訳エディタを開きます。  
［完了］タブを開き、左側の元の文言を参考に、右側に翻訳後の日本語を入力します。  
例えば左側が「すべて見つかりました」であれば右側を「全ての異変が見つかりました」のように入力します。  

![翻訳エディタの図解](https://github.com/user-attachments/assets/4684abce-ca3c-43da-802f-b9fba415367d)

英語対応する場合は、同様に英語行のボタンから英語の翻訳エディタを開き、「All aomalies found」などと英語の翻訳文を入力します（外国語の場合は対象となるタブが［完了］だけでなく［未翻訳］や［要レビュー］などに分散している可能性があります）。  
翻訳が完了したら、［Osagashi］タブの［テキストをコンパイル］ボタンを左クリックし、翻訳のコンパイルが完了するのを待ち、［OK］ボタンが表示されたらそれを左クリックして閉じます。  

そして［ゲームターゲット］の「OsagashiAdvance」も「Osagashi」と同様に翻訳とコンパイルを行います。  

正しく翻訳・設定できていればエディタ上でプレイ（スタンドアロンゲームモード）すれば翻訳が反映されていると思います。  
もし上手く翻訳できない場合は、手間ですが個別にテキストの該当箇所を探して直接テキストを書き換えてください。  

なお、ローカリゼーションダッシュボートの仕様なのか使い方が正しくないのか、パッケージ化した場合にレベル上の3Dテキストが翻訳できない場合がある現象を確認しています。  
ローカリゼーションダッシュボート自体がまだ実験段階であり、かつ3Dテキストもベータ段階のため、現時点では直接、該当箇所のテキストを書き換えることで対応する方法しかわかりません。  

クリア後の見つかっていない異変の案内に関しては、Osgs_BP_Actor_NotFounds_3DTextアクター（/Content/Osagashi/Blueprint/Actor/NotFounds/Osgs_BP_Actor_NotFounds_3DText.uasset）の［NotFoundsText］変数と［AllFoundsText］変数のテキストを書き換えると良いでしょう。  
どうしても上手くいかない場合は、この異変の案内をなくしてしまう判断も検討してください。一応、ゲーム内メニューから異変の情報は確認できますし、ゲーム開発を始めて間もない段階だと数日試行錯誤しても解決できずゲームがいつになっても完成しないリスクもあります。  
まずはゲーム開発全体を経験することを目標に、ゲームを完成させることを目指しましょう。  

### 異変作りについて
プログラミングせずに作る場合、フラグIDを元にオブジェクトの表示非表示を切り替えるだけになります。  

オブジェクトが大きくなる異変の場合は、通常のオブジェクトを複製し、複製したオブジェクトのサイズを大きくし、通常サイズと大きなサイズの両方を配置する形になります。そしてフラグIDに非表示用オブジェクトとして通常時のオブジェクトを、表示用オブジェクトとしてサイズ変更したオブジェクトを設定することになります。  
これにより表示非表示・位置・回転・大きさが変わる異変をプログラミング不要で実現します。  

異変用のオブジェクトはステップ3の段階で複製して作れば良いと思うので、レベル作成段階ではあまり深く意識しなくても良いかもしれません。  

なお、異変の有無は完全にステージに入ってから（サンプルレベル上のEntryFrontTriggerアクターのエリアに入ってから）視認できるようにしてください。  
入る前から異変が見えてしまって引き返してもシステム上は回答扱いにならず、そのまま進んでしまうと逆走による失敗扱いになる恐れがあります。  

## メニューをカスタマイズ
ゲーム内メニューは主にOsgs_Advance_WBP_Pause_Contentウィジット（/Content/Osagashi_Advance/UI/Pause/Osgs_Advance_WBP_Pause_Content.uasset）の編集でカスタマイズ可能です。  

### 不要な項目を消す
例えばモード変更機能を無くすのであれば、Osgs_Advance_WBP_Pause_Contentウィジットの「デザイナー」（エディタ右上の［デザイナー］［グラフ］ボタンで切替）から、モード選択のエリアを選択し、右側の詳細の［動作 > Visibility］を「Collapsed」に変更するだけです。  
この時に「Hidden」を選んでも非表示になりますが、この場合は本来その項目が表示されたはずのエリアが残ったままの歯抜け状態になります。好みに応じて使い分けてください。  

![Osgs_Advance_WBP_Pause_Contentの項目非表示方法の図解](https://github.com/user-attachments/assets/db0aec2d-0b50-4775-8f1c-12bd2cf01ac3)

この要領で他の表示したくない項目も非表示にできます。  
最低限「レジュームボタン（ゲームに戻る）」「環境設定ボタン」「終了ボタン」と「著作権表記」が程度あれば十分といえます（逆に機能・メニューが多すぎてもプレイヤーが混乱するだけとも言えます）。  
操作方法やインフォーメーションに関しては、ストアページなどに表示しても問題ないでしょう（そもそもゲーム内の操作方法や説明などを読まないプレイヤーも少なくない）。  

ただしギャラリー機能は開発中のフラグのテストで便利なので、せめて開発中は表示する方が良いでしょう（その場合はリリース時に消し忘れないように注意しましょう）。  

## 操作方法のキー設定
キャラクターの操作やメニュー表示などのキーはそれぞれ設定ファイルが分かれています（詳しくは[Unreal EngineのEnhanced Input](https://dev.epicgames.com/documentation/ja-jp/unreal-engine/enhanced-input-in-unreal-engine)などを参照してください）。  

* キャラクター…Osgs_IM_Character（/Content/Osagashi/Input/Osgs_IM_Character.uasset）
* メニュー…Osgs_IM_Pause（/Content/Osagashi/Input/Osgs_IM_Pause.uasset）
* インタラクト（写真を撮る）…Osgs_IM_Interact（/Content/Osagashi/Input/Osgs_IM_Interact.uasset）

必要に応じてキーを変更したり、キーを追加することが可能です。  
特定の操作を無効化したい場合はキーを［None］に設定します。  

変更内容によってはゲーム内メニューの操作方法を変更するか、非表示にしてストアページなどで説明しましょう。  

なお「ジャンプ」はサンプルとして用意しているだけで、基本的には無効化しても良いと思われます。  
ジャンプは想定外のスタックを引き起こすだけでなく、想定外ルートでの移動が行われる恐れがあり、進行先のレベルが読み込まれないなど進行不能バグを引き起こす可能性が高いです。  

また「しゃがみ」や「ズーム」に関しても、プレイヤーによっては操作方法からメタ読みして「しゃがみ」や「ズーム」を使わないとクリアできないと予想して、無駄なプレイをしてゲーム体験を自ら損なうケースもあります。  
「ダッシュ」に関しては逃げる必要があるとなどメタ読みするケースもありますが、快適プレイを補助する要素にもなりえるためホラーゲームなどダッシュで雰囲気や恐怖感を損なうなどの理由がなければ無効にしない方が良いと思われます。  

### 操作方法画面のカスタマイズ
操作方法画面はOsgs_Advance_WBP_Control_Contentウィジット（/Content/Osagashi_Advance/UI/Control/Osgs_Advance_WBP_Control_Content.uasset）になります。  

![操作方法Widgetカスタマイズの図解](https://github.com/user-attachments/assets/46877029-d2bc-406d-95c3-6574185c17ab)

例えば「ジャンプ」を無効化した場合は、まずジャンプの見出しと操作ボタンの［Visibility］を［Collapsed］に設定し非表示にします（非表示にしただけではレイアウト的に余分な空白ができる）。  
次にGridPanel（罫線が透明の3列×9行の表スタイル）のジャンプ行となるRowFillの「インデックス[5]」の値を「0.0」にします（これでジャンプ行の高さがゼロになる）。  

また各操作キーの画像を変更することも可能です（画像が用意されていないキーがある場合は自作したり画像素材を利用したりする必要があります）。  

## プレイヤーのパラメーター
プレイヤーの移動速度やジャンプ力などはコントローラーかプレイヤーのブループリントのパラメーターで変更します。  
これはあくまでもこのゲームのテンプレートの場合であって、使用するキャラクターやライブラリなどによっても異なります。  

### プレイヤーコントローラー（歩く速度・走る速度））
コントローラーのパラメーター変更はOsgs_Advance_BP_Controller_Helper_ActorComponentブループリント（/Content/Osagashi_Advance/Blueprint/Controller/Helper/Osgs_Advance_BP_Controller_Helper_ActorComponent.uasset）で行います。  

画面中央上部の［クラスのデフォルト］ボタンを左クリックし、右側の詳細タブの次変数を変更します。  

* SprintSpeed（走る速度）
* WalkSpeed（歩く速度）

### キャラクター（カメラの高さ・ジャンプ力）
キャラクターのパラメーター変更はOsgs_BP_Characterブループリント（/Content/Osagashi/Blueprint/Character/Osgs_BP_Character.uasset）で行います。  

画面中央上部の［クラスのデフォルト］ボタンを左クリックし、右側の詳細タブの次変数を変更します。  

* BaseEyeHeight（カメラの高さ）
* JumpZVelocity（ジャンプ力）

### デカール（ゲーム内オリジナルポスターの作り方）
サンプルの禁煙や広告のポスターはDecal（デカール）で表示しています。  
デカールはデコボコした表面にも画像を表示することが可能で、レベル内に画像を表示する時に便利な方法の1つです。  

まずゲーム内に表示する画像ファイルをTextureフォルダ（/Content/Osagashi/Texture）などわかりやすいフォルダにドラッグ＆ドロップなどでインポートします。  

次にベースとなるデカール用のOsgs_M_Decalマテリアル（/Content/Osagashi/Material/Decal/Osgs_M_Decal.uasset）を右クリックしてメニューを表示し、その中の［マテリアルインスタンスを作成］を左クリックします。  
自動的に同じフォルダ内に「Osgs_M_Decal_Inst」などの名前のマテリアルインスタンスが作成されるので、まずはわかりやすい名前に変更しておきましょう。  

![Osgs_M_Decal_Posterからマテリアルインスタンを作成する図解](https://github.com/user-attachments/assets/6f808632-5c39-4c00-b738-ae089c7ab4f6)

そしてこのファイルをダブルクリックして開きます。  
開いたら、右側の詳細タブの［パラメータ グループ > Global Texture Parameter Values］の［Tex］をチェック有の状態にし、その右側の項目に先程インポートした画像を指定します。  

後はレベル内にこのマテリアルインスタンスをドラッグ＆ドロップで配置するだけです。  
恐らくデカールの画像が大きく表示されると思うので、そのデカールを選択状態にし、詳細タブの［デカール > Decal Size］でサイズを調整し、好みの場所と角度で配置してください。  

![レベル上でデカールのDecalSize変更箇所の図解](https://github.com/user-attachments/assets/0fed3265-6382-4dee-a24b-72989c24a5db)

## ゲームの画質について
初期設定ではUnreal Engineの高画質なグラフィックが有効になっており、処理負荷が高く、低スペックなプレイ環境では快適性が犠牲になってしまいます。  
特に「Lumen」の影響が大きいと思われます。  

LumenはUnreal Engine 5の新機能で、完全に動的なグローバルイルミネーションおよび反射のシステムです。  
これにより自動に光と影がリアルに近い表現となり、初心者でもそれなりに見栄えの良いグラフィックのゲームを作れるようになります。  

Lumenは次世代コンソールやハイエイド環境向けに設計されており、PlyaStation 5やXbox Series Xやそれに匹敵する性能のゲーミングPC向けになっています。  
まだまだLumenの開発は継続されていますが、現状では60FPSを安定的に出すことすら簡単ではないのが現状のようです。  

Lumenを無効化すれば大幅に負荷を軽減できるのですが、グラフィックをかなり犠牲することになります。  
ポストプロセスなどで対応可能のようですが、それには知識・スキルが必要になるようです。  

Lumenを無効化した場合のイメージとしては、[Nintendow Switch版「8番出口」](https://www.youtube.com/watch?v=AlGNtXqMK_c)が参考になるかもしれません。
Switch版とPC版の「8番出口」の見た目が明らかに異なっているかと思いますが、これはLumenがそもそもSwitchに対応しておらず、Lumenが無効になっているためと思われます。

一応、ゲーム内環境設定の5段階の画質設定でLumenを有効にしつつ各種パラメーターを調整して画質とパフォーマンスのバランスを図ってはいます。
しかし、低スペック環境では厳しいのが現状です。  
さらにゲーム実況・VTuberが実況する場合は、録画・配信ソフトやアバターの処理負荷もあり、ミドルクラスのプレイ環境でも画質を下げないとパフォーマンスに影響が出ることがあります。  

そもそもゲームのパフォーマンスチューニングには知識・スキルが求められるものなので、はじめは画質を犠牲にするか要求スペックを高くする判断が必要かもしれません。  

### 画質のカスタマイズ
特に画質にこだわらない、もしくは画質を妥協してでも要求スペックを下げたい場合、大きく2つの対応方法があります。  

* プロジェクト設定
* ゲーム内画質設定（中・上級者向け）

#### プロジェクト設定
プロジェクト設定はエディタ上部の［編集 > プロジェクト設定］を左クリックで開きます。  
なおプロジェクト設定から色々な変更を行えますが、影響範囲が大きいものもあるためよくわからないで変更しないように注意してください。  

簡単な画質（負荷軽減）に関係する項目を紹介します。  

##### ターゲットハードウェア
プロジェクト設定の［プロジェクト > ターゲットハードウェア］を開きます。  
デフォルトでは「Desktop」「Maximum」と最高設定になっているので必要に応じて下げてみてください（変更後はプロジェクト設定に指示に従ってエディタの再起動が必要になると思います）。  

![プロジェクト設定のターゲットハードウェアの設定個所の図解](https://github.com/user-attachments/assets/993b3a04-3303-4c95-93e2-9c759caa16d0)

##### アンチエイリアス手法
アンチエイリアスは曲線などをボカして綺麗に見せる処理です。  
当然、品質重視にすると負荷は高くなります。  

プロジェクト設定の［エンジン > Rendering］を開き、［Default Settings > アンチエイリアス手法］から設定可能です。  

![アンチエイリアス手法の設定個所の図解](https://github.com/user-attachments/assets/321bdaef-f181-4bf5-ad36-30999d288fa7)

初期設定の「TSR」は負荷が高く「TAA」「FXAA」「None（アンチエイリアス無し）」の順に負荷が下がります（画質も下がる）。  
※「MSAA」はよくわかりませんでした。

#### ゲーム内画質設定（中・上級者向け）
ゲーム内メニューの環境設定で画質を5段階から選択できるようになっていますが、そこで行われる画質設定はOsgs_Advance_BP_GraphicSettingComponentアクターコンポーネント（/Content/Osagashi_Advance/Component/GraphicSetting/Osgs_Advance_BP_GraphicSettingComponent.uasset）で切り替えています。  

このファイルをダブルクリックして開き、エディタ上部中央あたりに表示される［クラスのデフォルト］ボタンを左クリックします。  
そして右側に表示される詳細タブの［品質 > Qualities］に配列として5段階の画質設定を設定しています。  

![Osgs_Advance_BP_GraphicSettingComponentのQualityMapping設定個所の図解](https://github.com/user-attachments/assets/f440b487-97bc-493e-8743-aa5b08b3d92d)

上から順に「最低画質」「低画質」「標準画質」「高画質」「最高画質」となっています。  
ただしこの順番はQualityMapping変数のIndex値と紐づいており、この値を変更すると画質設定にも影響します（基本的には変更するべきではありません）。  

* 1 = 最低画質
* 3 = 低画質
* 5 = 標準画質
* 7 = 高画質
* 9 = 最高画質

そして画質別にUnreal EngineのGameUserSettingsで指定できる画質の値をプリセットとして設定しています。  
なおこれらの値を下げると顕著に画面表示に影響することがあり、中にはゲームプレイに影響しかねないので、画質を下げる変更を行う時はテストプレイで変化を確認するようにしてください。特に明るい所や暗い所、一部のエフェクトでのみ変化が顕著になることがあるので、影響がありそうな箇所は特に注意してください。  

比較的簡単に変更できる項目は「ResolutionScaleNormalized」です。  
数値を下げると動画の解像度を下げた時のように、単純に画面が荒くなります。  

「ShadowQuality」（影）を0（無効化）にすることで負荷の大幅な軽減が期待出来はしますが、影がなくなるだけで顕著に見栄えが悪くなる可能性が高いので注意してください。  
数値を下げると、対象物に近づいた時に遅れて影が描写するため不自然になる恐れがあります（異変探しゲームでは不自然さ抑えたい）。  
ただ現実世界の影はコストゼロですが、ゲームの世界では光源の位置や周囲の遮蔽物など広範囲にたくさんの計算が必要なため負荷が高いとされています。  

また5段階の画質ごとに「PostProcessVolume」を設定できるので、ここで「Lumen」の無効化もできます。  

##### 初期画質の変更（中・上級者向け）
画質の初期値はOsgs_Advance_BP_SaveGame_Settingsブループリント（/Content/Osagashi_Advance/Blueprint/SaveGame/Settings/Osgs_Advance_BP_SaveGame_Settings.uasset）で設定しています。  

［表示 > ImageQuality］変数の値が、Osgs_Advance_BP_GraphicSettingComponentのQualityMapping変数と紐づいています。  
仕様変更がなければ、恐らく初期値は「3」（低画質）になっていると思われます（Steamの統計では低スペック環境のプレイヤーも多く、かつゲーム実況では配信ソフトなどの負荷によりミドルスペックでも性能不足になりやすいため、初期値を低画質にしています）。  

例えばこの値を「5」に変更すると初期画質が「標準画質」になります。  
この値は環境設定で変更されるセーブ・ロード対象の値であり、プレイヤーが変更しておりセーブ・ロードが完了していると、次回以降はプレイヤーが設定した画質で描画されます。  

## フォント
Unreal Engine標準のフォントは日本語対応にはなっていますが、日本人からすると不自然に感じるものが一部あります。  
フォントをゲームに組み込むことも可能ですので、余力があれば自作ゲームに組み込んでも良いかもしれません。  

# 発展編

## トラップアクター
トラップ系ギミックのサンプルとしてOsgs_BP_Actor_Trap_Thornアクター（/Content/Osagashi/Blueprint/Actor/Trap/Osgs_BP_Actor_Trap_Thorn.uasset）があります。  
サンプルゲームの壁男で使用しています。  

レベル上に配置したトラップ用のトリガーをこのアクターのTrigger変数に設定しており、このトリガーにプレイヤーが触れると失敗処理を実行するようになっています。  

この罠を常時移動させたり細い道の下に広げたりすればアクション要素を追加できますし、プレイヤーを襲うキャラクターに付けるといった使い方もできます。  

## 別プロジェクトに移行する（上級者向け）
このゲームのテンプレートを別のUnrealプロジェクトファイルに移行し、移行先で実行する手順を説明します。  

移行には大きく2パターンあります。  
1つはフラグ管理基本プログラム一式とサンプル一式（ゲーム内メニューとセーブ・ロード処理を除く）のみの移行。  
もう1つはこのゲームのテンプレートの全ての移行。  

参考までに各ディレクトリの依存関係と、ディレクトリ別のプレフィックスは次の通りです。  
* Findloople（依存なし） = FLE_
* Osagashi（「Findloople」に依存） = Osgs_
* Osagashi_Advance（「Findloople」と「Osagashi」と「Lelool」に依存） = Osgs_Advance_
* Lelool（依存なし） = Lelool_

### フラグ管理基本プログラム一式とサンプル一式のみ使用する移行方法
この移行方法ではゲーム内メニューが表示されず、かつ環境設定内容だけでなくゲームの進行のセーブ・ロードも行われません。
上級者が別システムと統合するような場合の移行方法になるかと思います。  

まずは移行先のプロジェクトで次のプラグインが有効になっていない場合は有効にします（設定変更後はエディタの再起動が必要）。  
* Text 3D

次のディレクトリが移行に必要となります。  
* Findloople（フラグ管理の基本プログラム一式）
* Osagashi（ゲーム内メニューとセーブ・ロード処理を除くサンプル一式）

ファイルの移行が成功したら［プロジェクト設定 > プロジェクト > マップ&モード］の設定を行います。  
［デフォルトのゲームモード］にOsgs_BP_GameMode（/Content/Osagashi/Blueprint/GameMode/Osgs_BP_GameMode.uasset）を設定します。  
［ゲームのデフォルトマップ］にOsgs_Level_Top（/Content/Osagashi/Level/Osgs_Level_Top.umapを設定します。  
「ゲームインスタンス」にOsgs_BP_GameInstance（/Content/Osagashi/Blueprint/GameInstance/Osgs_BP_GameInstance.uasset）を設定します。  

移行先のプロジェクト自体にエラーが発生していなければ、移行先でこのゲームのテンプレートが動作するようになると思います（ゲーム内メニューとセーブ・ロード処理はありません）。

### 全てを使用する移行方法
まずは移行先のプロジェクトで次のプラグインが有効になっていない場合は有効にします（設定変更後はエディタの再起動が必要）。  
* Text 3D
* Common UI Plugin

次のディレクトリが移行に必要となります。  
* Findloople（異変管理の基本プログラム一式）
* Osagashi（ゲーム内メニューとセーブ・ロード処理を除くサンプル一式）
* Osagashi_Advance（ゲーム内メニューとセーブ・ロード処理一式）
* Lelool（Osagashi_Advanceが使用するライブラリ一式）

ファイルの移行が成功したら［プロジェクト設定 > プロジェクト > マップ&モード］の設定を行います。  
［デフォルトのゲームモード］にOsgs_Advance_BP_GameMode（/Content/Osagashi_Advance/Blueprint/GameMode/Osgs_Advance_BP_GameMode.uasset）を設定します。  
［ゲームのデフォルトマップ］にOsgs_Level_Top（/Content/Osagashi/Level/Osgs_Level_Top.umapを設定します。  
「ゲームインスタンス」にOsgs_Advance_BP_GameInstance（/Content/Osagashi_Advance/Blueprint/GameInstance/Osgs_Advance_BP_GameInstance.uasset）を設定します。  

移行先のプロジェクト自体にエラーが発生していなければ、移行先でこのゲームのテンプレートが動作するようになると思います（ゲーム内メニューを使用するにはCommon UI Pluginの設定も行う必要があります）。

#### Common UI Pluginの設定
ゲーム内メニューのゲームパッド・キーボード＆マウスのボタン・キー表記やそのショートカットキー操作に対応するための設定が必要です。  
もし移行先のプロジェクトで既に設定された場合は調整が必要になるかもしれません。  

［プロジェクト設定 > ゲーム > Common Input Settings］を開きます。  
［インプットデータ］にOsgs_Advance_CommonUIInputData（/Content/Osagashi_Advance/UI/Osgs_Advance_CommonUIInputData.uasset）を設定します。  
［プラットフォーム入力 > Windows > Default］の［デフォルトの入力タイプ］を［Gamepad］に設定し、［デフォルトのゲームパッド名］に［Generic］を設定、コントローラーデータには次の2つを設定します。  
* Lelool_CommonUI_CommonInputBaseControllerData_Gamepad（/Lelool/UI/Lelool_CommonUI_CommonInputBaseControllerData_Gamepad.uasset）
* Lelool_CommonUI_CommonInputBaseControllerData_MouseAndKeyboard（/Lelool/UI/Lelool_CommonUI_CommonInputBaseControllerData_MouseAndKeyboard.uasset）

最後に［プロジェクト設定 > エンジン > 基本設定 > ゲームのビューポートクライアントクラス］に［CommonGameViewportClient］を設定します（設定を変更した場合はエディタの再起動を求められると思うので、その場合は指示に従って再起動してください）。

これらの設定により、ゲーム内メニューにゲームパッドとキーボード&マウスのショートカットキーの表示と、ショートカット操作が行えるようになるかと思います。

##### 移行時の不具合
移行時の不具合としてゲーム内メニューの一部が正常に表示されない現象が発生することがあるようです。  
* 異変一覧
* インフォメーション
* 環境設定

ゲーム内メニューは不具合の原因はわかっておらず、Common UI Pluginがまだベータ版であることが原因の可能性も考えられます。  
通常はリスクのある対応方法ではあるのですが、エディタの移行機能を使わずゲーム内メニューのファイル一式（/Content/Osagashi_Advance/UI）を直接コピーして上書きすることで正常に動作することは確認できました。  

# ゲーム作成・異変作成時の注意点

## 色の識別は避ける（アクセシビリティ）
赤と青を見分けるのが苦手など、色の識別が苦手な人は少なくありません（日本人男性20人に1人の割合でいると言われています）。  
またディスプレイなどプレイ環境でも見え方が異なることもありえます。  

色の違いの変化だけでなく、青い道と赤い道を選ばせるような時は色以外でも区別できるオブジェクトなどを配置するようにしましょう。  

## 小さな位置・角度・サイズだけの変化は避ける
ゲーム画面上では小さな位置・角度・サイズの変化の視認は難しく、小さな変化では閉じていたドアや目などが開くような意味を伴う必要があります（閉じていたドアが少し開いているのは認識できても、5度開いていたドアが10度開いた程度では視認が難しい）。  
そのためゲームのアニメーションでは現実の関節の可動域を超えてオーバーに動かすぐらいです。  

## 無音プレイを想定する
外出先などノートPCやスマートフォンなどでプレイする場合は、無音でプレイしていたり電車などの騒音でかき消されたりする可能性があります。  
そのため音だけでしか認識できない異変などは避けた方が良いでしょう。  

# よくある質問
このゲームのサンプルはライセンスが非常に緩いMITライセンスで公開しており、ライセンスを守ってライセンス表記さえすれば非常に自由度が高いです。  
もちろん、他に併用するライブラリなどがある場合はそれらのライセンスの確認は必要です。  

## サンプルゲームをゲーム実況しても良いですか？
問題ありません。  

## このゲームのテンプレートで作ったゲームを有料で販売しても良いですか？
問題ありません。  

## このゲームのテンプレートで作ったゲームのソースコードは非公開でも良いですか？
問題ありません。  

## このゲームのテンプレートの有料教材を作っても良いですか？
問題ありません。  

## このゲームのテンプレートを有料の勉強会の教材に使っても良いですか？
問題ありません。  

## このゲームのテンプレートでお探しゲーム・8番ライク以外を作っても良いですか？
問題ありません。  

## このゲームのテンプレートの一部を別のゲームに流用しても良いですか？
問題ありません。  

## このゲームのテンプレートで有償の開発代行・受注開発を行っても良いですか？
問題ありません。  

## エディタのレイアウトが変になってしまったのですが？
エディタ上部の［ウィンドウ］から［レイアウトをロード > デフォルトのエディタレイアウト］を左クリックすれば、エディタのレイアウトが初期状態に戻ります。  

![デフォルトのエディタレイアウトに戻すための項目の位置の図解](https://github.com/user-attachments/assets/dfd929d4-1182-45d9-938d-819f5c994c7a)
